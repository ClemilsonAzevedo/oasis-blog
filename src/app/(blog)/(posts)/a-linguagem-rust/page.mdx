---
title: A linguagem Rust
category: "rust"
publishDate: 2024-07-24T11:00:00Z
---

import Image  from 'next/image'

<div className="space-y-5">
  <div className='space-y-4'>
    <div>
      <span className='px-3 py-[6px] rounded-[6px] bg-blogYellow text-blogWhite text-sm font-medium leading-5'>Tecnologia</span>
    </div>
    # A linguagem Rust
  </div>
  <div className="flex items-center gap-1 not-prose text-zinc-500 text-sm">
    <div className='flex items-center gap-2'>
      <Image src={'https://github.com/clemilsonazevedo.png'} width={28} height={28} className='rounded-full' />
      <div className='flex items-center gap-6'>
        ######  Tracey Wilson
        <time style={{ fontFamily: 'Work Sans, sans-serif', fontSize: '14px' }}>
          {new Date("2024-07-24T11:00:00Z").toLocaleDateString('pt-BR', {
            dateStyle: 'medium',
          })}
        </time>
      </div>
    </div>
  </div>
</div>


## Função de mais alto nível no Rust

No rust nós temos uma função que está no top level, é onde todo o projecto executa, é de lá que parte o projecto.

E ela é declarada dessa forma.
```rust
	fn main (){}
```

Dentro dessa função é onde todo o bloco de código é executado.

Podemos fazer coisas simples como imprimir um **Hello World** na tela ou fazer outras funções, no primeiro caso que é imprimir um **Hello World** na tela, basta passar o comando println! para que o texto seja impresso no terminal.

```rust
	fn main (){
		println!("Hello World");
	}
```
Esse comando fará com que o o Hello World seja impresso na tela.

> println!
> O ==!== do ==println!== é um indicativo de que ele é um macro, ou seja é uma função que é executada quando chamada passando os parametros necessários que no caso é uma string.
> 
> Para mostrar os valores de uma variável dentro de um println!, precisamos abrir e fechar chaves dentro de aspas duplar e após uma virgula da string adicionar a variável.
> 
> 
```rust
	//Exemplo de como usar valores no printls!
	 fn main (){
		let hello_world: String = String::new("Hello World")
		println!("{}", hello_world);

	//Caso seja um array precisa-se usar o {:?}
		let lista_a = [i32; 5] = [1,2,3,4,5];
		println!("{:?}", lista_a)
	}
```

## Adicionar pacotes

Assim como temos no NPM ou outro package manager o cargo também tem o seu comando para adicionar pacotes.

> Cargo Add
> Para adicionar os pacotes no Rust, nós usamos o cargo com o seguinte comando
> ```bash
> cargo add packageName
> ```
> Com isso nós podemos fazer um build para compilar a aplicação e a seguir rodar o projecto e teremos o pacote adicionado
> ```bash
> cargo build
> cargo run
> ```

 >Pacotes do Cargo
> Podemos encontrar todos os pacotes disponíveis no cargo no site [Crates.io](https://crates.io/)

## Criar Variáveis no Rust

Para criar uma variável no Rust podemos usar o **let** e depois passar o tipo.

> Declarar variáveis
> Vamos focar em declarar uma string que se inicializa vazia.
> ```rust
> 	let name: String = String::new();
> ```

>Regras de Declaração de variáveis
>O padrão de declarar variáveis do Rust é Snake case ou seja toda separação de letras é por traço e é tudo em lower case.
>


# Fundamentos do Rust

#### Como funciona a memória dentro do Rust?

Existem duas **áreas de memória** para usar nas aplicações, são elas a ==Stack== e a ==Heap==

##### Memória Stack
>Stack
>É uma pilha, que respeita a LIFO, ==(Last In First Out)== e dentro da LIFO nós temos a lógica da pilha de execução dentro da aplicação.
>
>Ou seja, todas as funções são executadas em ordem de pilha, uma após a outra, tudo em ordem.
>```rust
>fn main(){
>	test_a();
>}
>
>fn test_a(){
>	test_b()
>}
>
>>fn test_b(){
>	!println("{}", 123)
>}
>```
>

>Stack
>>É uma regra do rust. Todos os dados que têm tamanho fixo, será colocado dentro da stack, é a área preferencial por ser mais rápida e mais organizada.


##### Memória Heap
>Heap
>É um aglomerado e é onde vão todos os dados que têm tamanhos variáveis.
>
>Ou seja, vai colocar dentro de uma area mais lenta e menos organizada.


>Main() 
>Todo o projecto em #programing/Rust Rust é iniciado a partir da função de mais alto nível que é a main() 

> Regras de Ownership
>- Cada valor tem um DONO
>- Só pode ter um DONO por vez
>- Dono fora do escopo -> o valor será eliminado
> ```rust
> 	//Nesse caso a variavel nome é dona do seu valor string que no momento é Rust, lembrando que o valor é armazenado na memória Heap já que o valor da string é variavel.
> 	
> 	fun main () {
> 		let nome: String = String::from("Rust");
> 	}
> ```
> 
> Quando vamos redeclarar uma variável, ela deixa de ser dona do seu valor e passa para a variável que chamou-a, ou seja, temos uma transferência de valor.
> ```rust
> 
> 	fun main () {
> 		let nome: String = String::from("Rust");
> 		let novo_nome: String = nome;
> 		
> 		println!("Nome {}", nome)
> 		//Nome ao ser chamado aqui no println! vai dar erro pois o nome perdeu o seu valor depois de ser passado para novo_nome
> 	}
> ```
> 
> Se por acaso precisarmos de redeclarar essa variável podemos usar o ```.clone()``` para pode clonar o valor da variável e poder usar normalmente após a redeclaração.import Image from 'next/image'import Image from 'next/image'
import Image from 'next/image'
import Image from 'next/image'
import Image from 'next/image'
import Image from 'next/image'

